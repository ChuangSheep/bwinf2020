using System;
using System.Linq;
using System.Collections.Generic;

namespace Aufgabe1
{
  // TODO: Consider refactoring every block as object instead of int[]
  public class FlohmarktManagement
  {
    public const int LENGTH = 10;
    public const int START_TIME = 0;
    public const int END_TIME = 10;
    private readonly List<int[]> demands;
    public List<int[]> Result { get; private set; }

    public int MaximumProfit { get; private set; }

    // DEBUG
    const int testCases = 15;


    public static void Main(string[] args)
    {
      /*

      var rbg = new RandomBlockGenerator(START_TIME, END_TIME, LENGTH, testCases, 2132512017);
      List<int[]> testData = rbg.GetResult();
      var bruteForce = new BFFind(testData);
      Console.WriteLine($"BF: {bruteForce.GetMaximum()}");

      FlohmarktManagement calc = new FlohmarktManagement(testData);
      calc.ProcessData();
      List<int[]> res = calc.Result;
      int maximum = calc.MaximumProfit;
      Console.WriteLine($"DP: {maximum}");
      Console.WriteLine("----------------");
      if (bruteForce.GetMaximum() != maximum)
      {
        Console.WriteLine($"Unconsistency: {rbg.Seed}");
      }

      */
      

      int inconsistencyCount = 0;
      List<int> inconsistencySeeds = new List<int>();
      // Datei einlesen
      for (int i = 0; i < 1000; i++)
      {
        var rbg = new RandomBlockGenerator(START_TIME, END_TIME, LENGTH, testCases);
        List<int[]> testData = rbg.GetResult();
        var bruteForce = new BFFind(testData);
        Console.WriteLine($"BF: {bruteForce.GetMaximum()}");

        FlohmarktManagement calc = new FlohmarktManagement(testData);
        calc.ProcessData();
        List<int[]> res = calc.Result;
        int maximum = calc.MaximumProfit;
        Console.WriteLine($"DP: {maximum}");
        Console.WriteLine("----------------");
        if (bruteForce.GetMaximum() != maximum)
        {
          Console.WriteLine($"Inconsistency: {rbg.Seed}");
          Console.WriteLine("----___----");
          inconsistencyCount++;
          inconsistencySeeds.Add(rbg.Seed);
        }
      }
      

      Console.ReadKey();
    }

    public FlohmarktManagement(List<int[]> data)
    {
      demands = new List<int[]>();
      foreach (int[] item in data)
      {
        demands.Add((int[])item.Clone());
      }
      MaximumProfit = 0;
    }

    public void ProcessData()
    {
      if (demands.Count < 1) return;
      QuickSort.Sort(demands, 0, demands.Count - 1);

      Table[] dSheet = new Table[demands.Count + 1];
      Table empty = new Table();
      for (int c = 0; c < END_TIME - START_TIME; c++)
      {
        for (int r = 0; r < LENGTH; r++)
        {
          empty.Add(r, c, new DemandCombination(new List<int[]>()));
        }
      }
      dSheet[0] = empty;
      for (int index = 1; index <= demands.Count; index++)
      {
        int addedCurrentAtRow = LENGTH;
        Table current = new Table();
        int startCol = demands[index - 1][0] - 1;
        int height = demands[index - 1][2];
        // Fill unchanged field with last val
        for (int c = 0; c < demands[index - 1][1] - 1; c++)
        {
          for (int r = 0; r < LENGTH; r++)
          {
            current.Add(r, c, new DemandCombination(dSheet[index - 1].GetCell(r, c)));
          }
        }
        for (int c = 0; c < END_TIME; c++)
        {
          for (int r = 0; r < demands[index - 1][2] - 1; r++)
          {
            current.Add(r, c, new DemandCombination(dSheet[index - 1].GetCell(r, c)));
          }
        }
        // start with its end times
        for (int r = demands[index - 1][2] - 1; r < LENGTH; r++)
        {
          for (int c = demands[index - 1][1] - 1; c < END_TIME; c++)
          {
            DemandCombination highest = dSheet[index - 1].GetCell(r, c);
            int maxProfit = dSheet[index - 1].GetCell(r, c).CalcProfit();

            DemandCombination t1 = new DemandCombination(new List<int[]>() { (int[])demands[index - 1].Clone() });
            for (int i = index - 1; i >= 0; i--)
            {
              t1.AddRange(dSheet[i].GetCell(r, c));
              if (t1.IsCompatible(r, c))
              {
                if (t1.CalcProfit() > maxProfit || (t1.CalcProfit() == maxProfit && t1.Count() < highest.Count()))
                {
                  highest = t1;
                  maxProfit = t1.CalcProfit();
                }
                break;
              }
              t1 = new DemandCombination(new List<int[]>() { (int[])demands[index - 1].Clone() });
            }



            DemandCombination dc1 = new DemandCombination(new List<int[]>() { (int[])demands[index - 1].Clone() });
            dc1.AddRange(dSheet[index - 1].GetCell(r, c));
            dc1.DistinctSelf();
            if (dc1.IsCompatible(r, c) && dc1.CalcProfit() > maxProfit)
            {
              maxProfit = dc1.CalcProfit();
              highest = dc1;
            }

            for (int i = r; i >= height; i--)
            {
              DemandCombination dcU = new DemandCombination(new List<int[]>() { (int[])demands[index - 1].Clone() });
              dcU.AddRange(dSheet[index - 1].GetCell(i, c));
              dcU.DistinctSelf();
              if (dcU.IsCompatible(r, c))
              {
                if (dcU.CalcProfit() > maxProfit)
                {
                  highest = dcU;
                  maxProfit = dcU.CalcProfit();
                }
                break;
              }
            }

            DemandCombination dc = new DemandCombination(new List<int[]>() { (int[])demands[index - 1].Clone() });
            if (startCol >= 0) dc.AddRange(dSheet[index - 1].GetCell(r, startCol));
            dc.DistinctSelf();
            DemandCombination dc2 = new DemandCombination(new List<int[]>() { (int[])demands[index - 1].Clone() });
            dc2.AddRange(dc);
            if (r - height >= 0) dc2.AddRange(dSheet[index - 1].GetCell(r - height, c));
            dc2.DistinctSelf();
            // compare the profit
            if (dc.CalcProfit() >= maxProfit)
            {
              maxProfit = dc.CalcProfit();
              highest = dc;
            }
            if (dc2.IsCompatible(r, c) && dc2.CalcProfit() > maxProfit)
            {
              maxProfit = dc2.CalcProfit();
              highest = dc2;
            }
            if (dSheet[index - 1].GetCell(r, c).CalcProfit() <= maxProfit && addedCurrentAtRow == LENGTH)
            {
              addedCurrentAtRow = r;
            }

            if (r > addedCurrentAtRow)
            {
              dc = new DemandCombination(dSheet[index - 1].GetCell(r - addedCurrentAtRow - 1, c));
              dc.AddRange(current.GetCell(addedCurrentAtRow, c));
              if (startCol >= 0 && dc.IsCompatibleWith(dSheet[index - 1].GetCell(r, startCol), r, c)) dc.AddRange(dSheet[index - 1].GetCell(r, startCol));
              dc.DistinctSelf();
            }
            // Falls die Summe ist groesser als die letzte, ersetz diese
            if (dc.CalcProfit() > maxProfit)
            {
              maxProfit = dc.CalcProfit();
              highest = dc;
            }
            current.Add(r, c, highest);
          }

        }
        dSheet[index] = current;
      }
      Result = dSheet[demands.Count].GetCell(LENGTH - 1, END_TIME - 1).ToList();
      MaximumProfit = dSheet[demands.Count].GetCell(LENGTH - 1, END_TIME - 1).CalcProfit();
    }

    private static int CalcProfit(int[] item)
    {
      return item[2] * (item[1] - item[0]);
    }

    private class Table
    {
      private readonly DemandCombination[,] data;
      public Table()
      {
        data = new DemandCombination[LENGTH, END_TIME - START_TIME];
      }

      // Row and Col start at 0
      public void Add(int row, int col, DemandCombination tc)
      {
        data[row, col] = tc ?? throw new ArgumentNullException(nameof(tc));
      }

      public DemandCombination GetCell(int row, int col)
      {
        return data[row, col];
      }
    }


    private class DemandCombination : IEnumerable<int[]>
    {
      private List<int[]> combos;
      public DemandCombination(IEnumerable<int[]> init)
      {
        combos = new List<int[]>();
        foreach (int[] item in init)
        {
          combos.Add((int[])item.Clone());
        }
      }

      public void AddRange(IEnumerable<int[]> data)
      {
        foreach (var item in data)
        {
          combos.Add((int[])item.Clone());
        }
      }

      public void Add(int[] data)
      {
        combos.Add((int[])data.Clone());
      }

      public List<int[]> GetCombo()
      {
        return combos;
      }

      public void DistinctSelf()
      {
        combos = DemandCombination.Distinct(this).ToList();
      }

      public static IEnumerable<int[]> Distinct(IEnumerable<int[]> combo)
      {
        return combo.GroupBy(arr => arr[3]).Select(g => g.First());
      }

      // Ob die Elemente in der ggb. Liste mit einander kombinierbar
      public bool IsCompatible(int rowRestr, int colRestr)
      {
        return DemandCombination.IsCompatible(combos, rowRestr, colRestr);
      }

      public bool IsCompatibleWith(IEnumerable<int[]> set, int rowRestr, int colRestr)
      {
        DemandCombination dc = new DemandCombination(combos);
        dc.AddRange(set);
        return dc.IsCompatible(rowRestr, colRestr);
      }

      public bool IsCompatibleWith(int[] item, int rowRestr, int colRestr)
      {
        DemandCombination dc = new DemandCombination(combos)
        {
          item
        };
        return dc.IsCompatible(rowRestr, colRestr);
      }

      public int CalcProfit()
      {
        if (!IsCompatible(LENGTH, END_TIME)) throw new Exception("Calc Profit incompatible");
        int temp = 0;
        foreach (int[] item in combos)
        {
          temp += FlohmarktManagement.CalcProfit(item);
        }
        return temp;
      }

      public IEnumerator<int[]> GetEnumerator()
      {
        return combos.GetEnumerator();
      }

      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return GetEnumerator();
      }

      // rowRestr und colRestr faengt mit 0 an, welche bedeutet maximalZeile = (rowRestr + 1)
      public static bool IsCompatible(IEnumerable<int[]> set, int rowRestr, int colRestr)
      {
        for (int i = 0, count = 0; i <= colRestr; i++, count = 0)
        {
          foreach (int[] item in set)
          {
            if (item[1] > colRestr + 1) return false;
            if (item[0] <= i && item[1] >= i + 1) count += item[2];
          }
          if (count > rowRestr + 1) return false;
        }
        return true;
      }
    }

    // Angonommen, die eingegebenen Daten ist nicht nach End_time sortiert
    private static class QuickSort
    {
      public static void Sort(List<int[]> arr, int low, int high)
      {
        if (high <= low) return;

        int pIndex = Partition(arr, low, high);
        Sort(arr, low, pIndex - 1);
        Sort(arr, pIndex + 1, high);
      }

      private static int Partition(List<int[]> arr, int low, int high)
      {
        int i = low - 1;
        for (int j = low; j < high; j++)
        {
          if (arr[j][1] < arr[high][1] ||
          (arr[j][0] == arr[high][0] &&
          (arr[j][2] * (arr[j][1] - arr[j][0])) < (arr[high][2] * (arr[high][1] - arr[high][0]))))
          {
            Swap(arr, ++i, j);
          }
        }
        Swap(arr, ++i, high);
        return i;
      }

      private static void Swap(List<int[]> arr, int i1, int i2)
      {
        if (i1 == i2) return;
        int[] temp = arr[i1];
        arr[i1] = arr[i2];
        arr[i2] = temp;
      }
    }
  }


  // DEBUG
  // DO NOT Submit this class
  // TEST ONLY
  public class RandomBlockGenerator
  {
    private readonly List<int[]> Result;
    public readonly int Seed;
    public RandomBlockGenerator(int startTime, int endTime, int maximumHeight, int number, int? seed = null)
    {
      Result = new List<int[]>(number);

      Seed = seed == null ? Guid.NewGuid().GetHashCode() : (int)seed;
      Random rng = new Random(Seed);
      for (int i = 0; i < number; i++)
      {
        int[] current = new int[4];
        current[0] = rng.Next(startTime, endTime);
        current[1] = rng.Next(current[0] + 1, endTime + 1);
        current[2] = rng.Next(1, maximumHeight + 1);
        // AS id
        current[3] = i;
        Result.Add(current);
      }
      Console.WriteLine($"Using seed: {Seed}");
    }

    public List<int[]> GetResult()
    {
      return Result;
    }

    public void ToFile(string fileName)
    {

    }
  }


  // DEBUG
  // DO NOT Submit this class
  // TEST ONLY
  // USE FOR OBJECTS LESS THAN 20
  // O(2^n)
  public class BFFind
  {
    private readonly int[] table = new int[FlohmarktManagement.END_TIME - FlohmarktManagement.START_TIME];
    private int maximumProfit;
    private List<int[]> bestCombo;

    public BFFind(List<int[]> blocks)
    {
      maximumProfit = 0;
      bestCombo = new List<int[]>();

      IEnumerable<List<int[]>> combinations = Permutations(blocks);
      Console.WriteLine(combinations.Count());

      foreach (List<int[]> possible in combinations)
      {
        Check(possible);
      }
    }

    public int GetMaximum()
    {
      return maximumProfit;
    }

    public List<int[]> GetCombo()
    {
      return bestCombo;
    }

    private void Check(List<int[]> set)
    {
      int currentProfit = 0;
      for (int i = 0; i < table.Length; i++)
      {
        table[i] = 0;
      }

      foreach (var part in set)
      {
        for (int i = part[0]; i < part[1]; i++)
        {
          table[i] += part[2];
          currentProfit += part[2];
        }
      }
      if (Possible() && currentProfit > maximumProfit)
      {
        maximumProfit = currentProfit;
        bestCombo = set;
      }
    }

    private bool Possible()
    {
      foreach (int i in table)
      {
        if (i > FlohmarktManagement.LENGTH) return false;
      }
      return true;
    }

    public static IEnumerable<List<T>> Permutations<T>(IEnumerable<T> source)
    {
      if (null == source)
        throw new ArgumentNullException(nameof(source));

      T[] data = source.ToArray();

      return Enumerable
        .Range(0, 1 << (data.Length))
        .Select(index => data
           .Where((v, i) => (index & (1 << i)) != 0)
           .ToList());
    }

  }
}
